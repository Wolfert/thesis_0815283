\hoofdstuk{Developing cross-platform native applications with Titanium}
\paragraaf{Inner workings}

At runtime a mobile application developed with Titanium consists of three major components:
\begin{itemize}
	\item
	The JavaScript sourcecode
	\item
	A platform-specific implementation of the Titanium API
	\item
	A JavaScript interpreter
\end{itemize}

During runtime the JavaScript sourcecode will be incorporated in a native class where it is compiled as encoded as a string. The implementation of the Titanium API done in a platform specific native programming language, Java for Android and Objective-C for iOS. The JavaScript interpreter evaluates the JavaScript code at runtime. Each platform has its own specific JavaScript Interpreter.

V8 is the default for Android but Rhino is also supported. V8 is has a better performance dealing as Rhino because it is directly intergrated to the NDK\footnote{Native Development Kit}. This means it does the code does not have to run trough the JVM\footnote{Java Virtual Machine}. Performance gain can exceed over 200\% processing time when parsing a JSON object.\cite{Lukasavage2011}

For iOS JavaScriptCore is the choosen interpreter.

\subparagraaf{Runtime}
At runtime a JavaScript execution environment set up in the native evironment this is where the application sourcecode is evaluated. Injected into JavaScript execution environment are so called \emph{proxy} objects.

\subparagraaf{Proxy objects}
A proxy object is an JavaScript object with a paired object in native code.\cite{Whinnery2012} This means the object exists in both JavaScript and native code. Proxy objects gap the bridge between the native and the JavaScript environment. A global Titanium object in JavaScript exposes access to the proxy objects. 

So, for example var label = Titanium.UI.createTabel({ text: "label" }); will invoke a native method which creates a native UILabel object. 

var b = Ti.UI.createButton({title:'Title'});, that will invoke a native method that will create a native UI object, and create a “proxy” object (b) which exposes properties and methods on the underlying native UI object to JavaScript.
UI components (view proxies) can be arranged hierarchically to create complex user interfaces. Proxy objects which represent an interface to non-visual APIs (like filesystem I/O or database access) execute in native code, and synchronously (or asynchronously for APIs like network access) return a result to JavaScript. 


Par example: In the JavaScript code, when a function is called on the global Titanium object to create a native UILabel a proxy object is created.

\begin{minted}[mathescape,
			   label="JavaScript-object",
               linenos,
               numbersep=5pt,
               gobble=0,
               frame=lines,
               framesep=2mm]{js}

var label = Titanium.UI.createTabel({
   text: "Lorem impsum",
   top: 10,
   left: 10,
   width: 100,
   height: 20
});
\end{minted}


In iOS the proxy button object:

\begin{minted}[linenos,
				label="Native-object",
				samepage,
				tabsize=2,
				xleftmargin=0cm,
               numbersep=5pt,
               frame=lines,
               framesep=2mm]{objc}
-(UILabel*)label
{
    if (label==nil)
    {
        label = [[UILabel alloc] initWithFrame:CGRectZero];
        label.backgroundColor = [UIColor clearColor];
        label.numberOfLines = 0;
        [self addSubview:label];
    }
    return label;
}
\end{minted}

\paragraaf{JavaScript}
\paragraaf{CommonJS}
\paragraaf{Modules}

\paragraaf{Eclipse}
\paragraaf{Buildsystem}
\paragraaf{XCode CLI and the iOS SDK}
\paragraaf{Android SDK}


\paragraaf{Performance versus flexibility}
tableview.